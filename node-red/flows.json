[
    {
        "id": "dd55f774d9b5b325",
        "type": "tab",
        "label": "Ingest Shelly MQTT",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3b44ba5a1dc552c7",
        "type": "mqtt in",
        "z": "dd55f774d9b5b325",
        "name": "Shelly Status In",
        "topic": "+/status/switch:0",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "becc22b8f4461a4d",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 260,
        "wires": [
            [
                "6011c11b42aa9370"
            ]
        ],
        "info": "**Purpose:** Subscribes to the MQTT topics for all Shelly smart plugs. This is the primary entry point for live energy data.\n\n**Topic:** `+/status/switch:0`\n- The `+` is a single-level wildcard that captures the unique `shelly_id` from the topic (e.g., `SPPS-02`).\n\n**Output:**\n- `msg.topic`: The full topic string.\n- `msg.payload`: A JSON object containing the status report from the Shelly device, including power, energy, and voltage."
    },
    {
        "id": "6011c11b42aa9370",
        "type": "function",
        "z": "dd55f774d9b5b325",
        "name": "Parse Shelly Data",
        "func": "// msg.topic will be something like \"LAUDS_FabLab_3DP_Klimawandel/status/switch:0\"\n// msg.payload will be the parsed JSON object from the Shelly /status/switch:0 message\n\nconst topicParts = msg.topic.split('/');\nlet shellyId;\n\n// NEW: More robust way to find the Shelly ID.\n// It finds the 'status' part of the topic and assumes the ID is the part right before it.\nconst statusIndex = topicParts.indexOf('status');\nif (statusIndex > 0) {\n    shellyId = topicParts[statusIndex - 1];\n} else {\n    // Fallback to the original logic if 'status' isn't found\n    shellyId = topicParts[0];\n}\n\n// Extract data from the payload, using safe navigation (?. operator)\nlet power = msg.payload.apower;\nlet energyTotal = msg.payload.aenergy?.total;\nlet voltage = msg.payload.voltage;\nlet current = msg.payload.current;\nlet plugTempC = msg.payload.temperature?.tC;\n\n// This block correctly handles the other message type (.../events/rpc) by ignoring it.\n// We add a more descriptive warning.\nif (msg.payload.params?.[\"switch:0\"]?.aenergy?.total !== undefined) {\n    if (power === undefined) {\n        node.warn(`Skipping incomplete energy-only update from topic ${msg.topic}. This is the correct behavior as it lacks full data.`);\n        return null; // Stop processing this message further\n    }\n}\n\n// Validate required data. This is a critical check.\nif (shellyId === undefined || power === undefined || energyTotal === undefined) {\n    node.error(\"Missing required data (shellyId, power, or energyTotal) in payload for topic: \" + msg.topic, msg);\n    return null; // Stop processing this message\n}\n\n// Create a standard timestamp (Node-RED runs on UTC, PG needs TIMESTAMPTZ)\nconst timestamp = new Date().toISOString();\n\n// We need the internal device_id (e.g., ultimaker_2_solex) associated with this shellyId.\n// We'll fetch this using a separate database lookup in the next step.\n// For now, just pass the shellyId along.\nmsg.shellyId = shellyId;\n\n// Prepare the payload for the next step (lookup)\nmsg.payload = {\n    timestamp: timestamp,\n    power_watts: parseFloat(power) || 0,\n    energy_total_wh: parseFloat(energyTotal) || 0,\n    voltage: parseFloat(voltage) || 0,\n    current_amps: parseFloat(current) || 0,\n    plug_temp_c: parseFloat(plugTempC) || null // Allow NULL if temp missing\n};\n\n// Clear the original topic to avoid confusion downstream\nmsg.topic = \"\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 260,
        "wires": [
            [
                "dea9b58952db33f3",
                "880c7f6b7e9a735f"
            ]
        ],
        "info": "**Purpose:** Extracts the relevant energy metrics from the raw JSON payload and standardizes them into a consistent format.\n\n**Logic:**\n1.  Parses the `shelly_id` from the `msg.topic`.\n2.  Safely extracts `apower`, `aenergy.total`, `voltage`, etc. from the `msg.payload`.\n3.  Validates that essential data is present.\n4.  Creates a new, clean object with standardized keys (`power_watts`, `energy_total_wh`, etc.).\n\n**Output:**\n- `msg.shellyId`: The unique ID of the Shelly plug.\n- `msg.payload`: The new, standardized data object."
    },
    {
        "id": "dea9b58952db33f3",
        "type": "function",
        "z": "dd55f774d9b5b325",
        "name": "Lookup Device ID",
        "func": "// msg.shellyId contains the ID like \"SPPS-02\"\n// msg.payload contains the parsed energy data object\n\nif (!msg.shellyId) {\n    node.error(\"Shelly ID missing, cannot lookup device ID\");\n    return null;\n}\n\n// Prepare the parameters array for the Prepared Statement in the postgres node.\n// The query in the postgres node will expect $1 to be the shelly_id.\nmsg.params = [ msg.shellyId ];\n\n// Pass the energy data along for the next step using a different property\nmsg.energyData = msg.payload;\n\n// Clear payload and topic as they are not needed for the postgres node in this mode\nmsg.payload = {};\nmsg.topic = \"\"; // Ensure topic is empty\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 260,
        "wires": [
            [
                "b994af8ea200e124",
                "8a103cd81cf25cb4"
            ]
        ]
    },
    {
        "id": "2d8a7b2473e3360c",
        "type": "function",
        "z": "dd55f774d9b5b325",
        "name": "Prepare Insert Parameters",
        "func": "// msg.payload from the database node will be an array of results.\n// It should contain one object like [{ device_id: 'PrusaMK4-1' }]\n\n// **Improved Check:** Verify msg.payload is a non-empty array first\nif (!Array.isArray(msg.payload) || msg.payload.length === 0) {\n    // Log an informative error including the shellyId that failed the lookup\n    node.error(`Device ID lookup query returned no results for Shelly ID: '${msg.shellyId}'. Check if this Shelly ID exists in the 'devices' table.`, msg);\n    return null; // Stop processing this message flow\n}\n\n// Now we know msg.payload is a non-empty array. Access the first result.\nconst lookupResult = msg.payload[0];\n\n// **Improved Check:** Verify the result object and the device_id property exist\nif (!lookupResult || typeof lookupResult.device_id !== 'string' || lookupResult.device_id.trim() === '') {\n    node.error(`Device ID not found or is invalid in lookup result for Shelly ID: '${msg.shellyId}'. Result object received:`, lookupResult);\n    return null; // Stop processing\n}\n\n// If we reached here, the lookup was successful.\nconst deviceId = lookupResult.device_id;\nconst data = msg.energyData; // Retrieve the energy data we stored earlier\n\nif (!data) {\n    // This error shouldn't happen if the flow logic is correct, but check anyway\n    node.error(\"Internal Error: Energy data missing after successful device ID lookup for device: \" + deviceId);\n    return null;\n}\n\n// Prepare the parameters array in the correct order for the INSERT statement\n// Order MUST match the VALUES clause in the postgres node:\n// $1: timestamp, $2: device_id, $3: power_watts, $4: energy_total_wh,\n// $5: voltage, $6: current_amps, $7: plug_temp_c\nmsg.params = [\n    data.timestamp,        // $1\n    deviceId,              // $2\n    data.power_watts,      // $3\n    data.energy_total_wh,  // $4\n    data.voltage,          // $5\n    data.current_amps,     // $6\n    data.plug_temp_c       // $7\n];\n\n// Clear unnecessary properties that might interfere\ndelete msg.payload;\ndelete msg.topic; // Ensure topic is clear as we're not using it for the query\ndelete msg.energyData;\n// We keep msg.shellyId here so the error messages above have context, but it's not used further.\n// delete msg.shellyId; // Optional: uncomment to remove it fully\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 320,
        "wires": [
            [
                "873bd32f3e178cc0",
                "e04ec9e0e6c9a3a5"
            ]
        ]
    },
    {
        "id": "873bd32f3e178cc0",
        "type": "postgresql",
        "z": "dd55f774d9b5b325",
        "name": "Insert Energy Data",
        "query": "INSERT INTO energy_data (\n    timestamp,\n    device_id,\n    power_watts,\n    energy_total_wh,\n    voltage,\n    current_amps,\n    plug_temp_c\n)\nVALUES ($1, $2, $3, $4, $5, $6, $7)\nON CONFLICT (timestamp, device_id) DO NOTHING;",
        "postgreSQLConfig": "4259e91acb63e17b",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 1330,
        "y": 260,
        "wires": [
            []
        ],
        "info": "**Purpose:** The final step. This node inserts the standardized energy data into the `energy_data` hypertable.\n\n**Logic:**\n- The previous node (\"Prepare Insert Parameters\") formats `msg.params` with all the required values in the correct order.\n- An `INSERT` query is executed.\n- `ON CONFLICT DO NOTHING` prevents duplicate entries if a message is received twice."
    },
    {
        "id": "b994af8ea200e124",
        "type": "postgresql",
        "z": "dd55f774d9b5b325",
        "name": "Prepared Statement",
        "query": "SELECT device_id FROM devices WHERE shelly_id = $1;",
        "postgreSQLConfig": "4259e91acb63e17b",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 840,
        "y": 260,
        "wires": [
            [
                "2d8a7b2473e3360c"
            ]
        ],
        "info": "**Purpose:** Translates the public `shelly_id` into the system's internal `device_id`.\n\n**Logic:**\n- It queries the `devices` table to find the row `WHERE shelly_id = $1`.\n- This is a critical step to link the energy data to the correct printer.\n\n**Output:**\n- `msg.payload`: An array containing the query result, e.g., `[{ \"device_id\": \"PrusaMK4-1\" }]`.\n- `msg.energyData`: The original standardized energy data is preserved and passed through."
    },
    {
        "id": "e04ec9e0e6c9a3a5",
        "type": "debug",
        "z": "dd55f774d9b5b325",
        "name": "debug 22",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 320,
        "wires": []
    },
    {
        "id": "880c7f6b7e9a735f",
        "type": "debug",
        "z": "dd55f774d9b5b325",
        "name": "debug 23",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 320,
        "wires": []
    },
    {
        "id": "8a103cd81cf25cb4",
        "type": "debug",
        "z": "dd55f774d9b5b325",
        "name": "debug 24",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 320,
        "wires": []
    },
    {
        "id": "becc22b8f4461a4d",
        "type": "mqtt-broker",
        "name": "",
        "broker": "89.252.166.188",
        "port": "2010",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "4259e91acb63e17b",
        "type": "postgreSQLConfig",
        "name": "",
        "host": "localhost",
        "hostFieldType": "str",
        "port": 5432,
        "portFieldType": "num",
        "database": "reg_ml",
        "databaseFieldType": "str",
        "ssl": "false",
        "sslFieldType": "bool",
        "applicationName": "",
        "applicationNameType": "str",
        "max": 10,
        "maxFieldType": "num",
        "idle": 1000,
        "idleFieldType": "num",
        "connectionTimeout": 10000,
        "connectionTimeoutFieldType": "num",
        "user": "reg_ml",
        "userFieldType": "str",
        "password": "raptorblingx",
        "passwordFieldType": "str"
    }
]
